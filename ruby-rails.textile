h1. Ruby/Ruby on Rails Code Guideline (Work in progress)

It might be hard for you a developer that spent months and years by development of beautiful apps and programs, and himself developed his own style of writing code, to now change it and bend it satisfy this guidelines. However, because all of us have their own style, it might make it hard for others the read it. Moreover, as I mentioned in the on the beginning, we develop, we write our code differently than we did a couple of years ago. That makes it even harder. If we develop when working on a simple application, the code, the way we write methods, becomes inconsistent. It is not wrong. This is perfectly natural. But have you ever looked into your code that you created a long time ago and didn't understand it at all?

*The motivation of this document is simple:*
* *Unify the way we write our code*
* *Make it consistent and readable*
* *Allow newcomers to rapidly get involved in development of new or refactorization of old features*

h1. Coding Style

* Use @UTF-8@ as the source file encoding and always include Ruby's magic comment

<pre><code># encoding: UTF-8
</code></pre>

* Use soft-tabs with a two space indent
* Keep lines fewer than 80 characters
* Never leave trailing whitespace
* Use spaces around operators, after commas, colons and semicolons, around @{@ and before @}@. Whitespace might be (mostly) irrelevant to Ruby interpreter, but its proper use is the key to writing easily readable code

<pre><code>sum = 1 + 2
a, b = 1, 2
1 > 2 ? true : false; puts "Hello!"
[1, 2, 3].each { |e| puts e }
</code></pre>

The only exception is when using the exponent operator:
  
<pre><code># Wrong
e = M * c ** 2

# Right
e = M * c**2
</code></pre>

* Indent @when@ as deep as case

<pre><code>case
when song.name == 'Misty'
  puts 'Not again!'
when song.duration > 120
  puts 'Too long!'
when Time.now.hour > 21
  puts "It's too late"
else
  song.play
end

kind = case year
       when 1850..1889 then 'Blues'
       when 1890..1909 then 'Ragtime'
       when 1910..1929 then 'New Orleans Jazz'
       when 1930..1939 then 'Swing'
       when 1940..1950 then 'Bebop'
       else 'Jazz'
       end
</code></pre>

* Align the parameters of a method call if they span over multiple lines

*DISCUSS!!*

<pre><code># Wrong (line is too long)
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text)
end

# Wrong (double indent)
def send_mail(source)
  Mailer.deliver(
      to: 'bob@example.com',
      from: 'us@example.com',
      subject: 'Important message',
      body: source.text)
end

def send_mail(source)
  Mailer.deliver(
    to: 'bob@example.com',
    from: 'us@example.com',
    subject: 'Important message',
    body: source.text)
end

def send_mail(source)
  Mailer.deliver(to: 'bob@example.com',
                 from: 'us@example.com',
                 subject: 'Important message',
                 body: source.text)
end
</code></pre>

* Use empty lines between methods and to break a method into logical paragraphs

<pre><code>def some_method
  data = initialize(options)

  data.manipulate!

  data.result
end

def some_method
  result
end
</code></pre>

* Add underscores to big numeric literals to improve their readability

<pre><code># Wrong (How many 0s are there?)
number = 10000000

# Right
number = 10_000_000
</code></pre>


h1. Documentation

*DISCUSS!!*

h1. Syntax

* Use @def@ with parentheses when there are arguments. Omit the parentheses when the method accept any arguments

<pre><code>def some_method
  # ommited...
end

def some_method_with_arguments(argument1, argument2)
  # ommited..
end
</code></pre>

* Never use @for@, unless you know exacltly why. Most of the time iterators should be used instead. @for@ is implemented in terms of @each@ (so you're adding a level of indirection), but with a twist - for doesn't introduce a new scope (unlike @each@) and variables defined in its block will be visible outside it.

<pre><code>array = [1, 2, 3]
# Wrong
for number in array do
  puts number
end
</code></pre>

* Never use @then@ for multilie @if/unless@

<pre><code># Wrong
if some_condition then
  # ommited...
end

# Right
if some_condition
  # ommited...
end
</code></pre>


* Avoid the ternary operator (@?:@) except in cases where all expressions are extremely trivial. However, do use the ternary operator (@?:@) over @if/then/else/end@ constructs for single line conditionals.

<pre><code># Wrong
result = if some_condition then something else something_else end

# Right
result = some_condition ? something : something_else
</code></pre>

* Use one expression per branch in a ternary operator. This also means that ternary operators must not be nested. Prefer @if/else@ constructs in these cases.

<pre><code># Wrong
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

# Right
if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end
</code></pre>

* Use @and@ and @or@ keywords for control flow. In conditionsalways use @&&@ and @||@.
h1. Unit::Test with Shoulda
* Favour modifier @if/unless@ usage when you have a single-line body

<pre><code># Wrong
if some_condition
  do_something
end

# Right
do_something if some_condition
</code></pre>

* Never use @unless@ with @else@. Rewrite these with positive case first

<pre><code># Wrong
unless success?
  puts 'failure'
else
  puts 'success'
end

# Right
if success?
  puts 'success'
else
  puts 'failure'
end
</code></pre>

* Don't use parntheses around the condition of an @if/unless/while@, unless the condition contains an assignment

<pre><code># Wrong
if (x > 10)
  # ommited...
end

# Right
if x > 10
  # ommited...
end

# Ok
if (x = self.next_value)
  # ommited...
end
</code></pre>

* Prefer @{...}@ over @do...end@ for single-line blocks. Avoid using @{...}@ for multi-line blocks (multiline chaining is always ugly). Always use @do...end@ for "control flow" and "method definitions" (e.g. Rakefiles and certain DSLs). Avoid @do...end@ when chaining.

<pre><code>names = ["Bozhidar", "Steve", "Sarah"]

# Wrong
names.each do |name|
  puts name
end

# Right
names.each { |name| puts name }

# Wrong
names.select do |name|
  name.start_with?("S")
end.map { |name| name.upcase }

# Right
names.select { |name| name.start_with?("S") }.map { |name| name.upcase }
</code></pre>

* Avoid @return@ where not required

<pre><code># Wrong
def some_method(some_arr)
  return some_arr.size
end

# Right
def some_method(some_array)
  some_array.size
end
</code></pre>

* Use spaces arount the @=@ operator when assigning default values to method parameters

<pre><code># Wrong
def some_method(arg1=:default, arg2=[], arg3=nil)
  # ommited...
end

def some_method(arg1 = :default, arg2 = [], arg3 = nil)
  # ommited...
end
</code></pre>

* Avoid @self@ where not required. (It is only required when calling a self write accessor)

<pre><code># Wrong
def ready?
  if self.last_reviewed_at > self.last_updated_at
    self.worker.update(self.content, self.options)
    self.status = :in_progress
  end
  self.status == :verified
end

# Right
def ready?
  if last_reviewed_at > last_updated_at
    worker.update(content, options)
    self.status = :in_progress
  end
  status == :verified
end
</code></pre>

* Use @||=@ freely to initialize variables

<pre><code># Set name to Joe, only if it is nil or false
name ||= "Joe"
</code></pre>

* Never use @||=@ to initialize boolean variables. (Consider what would happen if the current value happened to be @false@)
* Avoid using Perl-style special varibales (like @$0-9@, @$@).
* Never put a space between a method name and opening parenthesis

<pre><code># Wrong
method (3 + 2) + 1

# Right
method(3 + 2) + 1
</code></pre>

h1. Naming

* Use @snake_case@ for methods and variables
* Use @CamelCase@ for classes and modules. (Kepp acronyms like HTTP, RFC, XML uppercase)
* Use @SCREAMING_SNAKE_CASE@ for other constants
* The names of predicate methods (methodsathat return a boolean value) should end in a question mark(e.g. @Array#empty?@)
* The names of potentially "dangerous" methods (e.g. methods that modify @self@ of the arguments) should en with an exclamation mark
* Define the non-bang (safe) method in terms of the bang (dangerous) one if possible

<pre><code>class Array
  def flatten_once!
    result = []
    each do |e|
      [*e].each { |f| result << f}
    end
    
    replace(result)
  end
  
  def flatten_once
    dup.flatten_once!
  end
</pre></code>

* When using iterators with short blocks, name the arguments @|a, e|@ (accumulator, element). For long blocks, prefer the full names (@|accumulator, element|@).
* When difining binary operators, name the arguments @other@.

<pre><code>def +(other)
  # ommited...
end
</code></pre>

* Prefer @collect@ over @map@, @find@ over @detect@, @select@ over @find_all@, @reduce@ over @inject@ and @size@ over @length@. Always prefer those methods that has self-explanatory name.

h1. Unit::Test with Shoulda

*Unit::Test is so great! Why do we need something, that I don't even know, like Shoulda?*

Unit::Test can be great when well written. But when the test file gets longer, when the tested class more complicated and when @test_presence_of_user_when_cloths_state_is_sold@ cannot be longer, it sometimes starts to be a challenge to understand it.

Shoulda introduces "contexts" to Unit::Test. This means that instead of using methods and their names to invoke tests, you use blocks with names. It also allows you to write atomic tests without the problem of running out of names for methods.

h2. Describe class

Shoulda is mainly about text and can get you a nice explanation of the problem when something goes wrong. For this reason, start writing you test by describing what class is the test about.


<pre><code># Wrong
class TestSimpleNumber < Test::Unit::TestCase
  context 'simple number' do
    # ommited...
  end
end

# Right
class TestSimpleNumber < Test::Unit::TestCase
  context 'SimpleNumber' do
    # ommited...
  end
end
</code></pre>


h2. How to describe you methods

Once you are inside the context that describes the class. Also use contexts that describes methods.

Keep clear the methods you are describing. As convention use . as prefix for class methods and # as prefix for instance methods.

<pre><code># Wrong
context 'the authenticate method for user' do
context 'if the user is an admin' do

# Right
context '.authenticate' do
context '#admin?' do
</code></pre>


h2. Single expectation test

The 'one expectation' means 'each test should make only one assertion'. All test should be atomic if possible. This helps you on finding possible errors, going directly to the failing test.

<pre><code># Wrong
should 'create a resource' do
  assert_difference('User.count') do
    post :create, :user => { :name => "Joe" }
  end
  assert_redirected_to user_path(assigns(:user))
end


# Right
should 'create a resource' do
  assert_difference('User.count') do
    post :create, :user => { :name => "Joe" }
  end
end

should 'redirect to user path' do
  assert_redirected_to user_path(assigns(:user))
end
</code></pre>

h2. Test all possible cases

Testing is a good practice, but if you do not test the edge cases, it will not be useful. Test valid, edge and invalid case. For example, consider the following action.

<pre><code>before_filter :find_owned_resources
before_filter :find_resource

def destroy
  render 'show'
  @consumption.destroy
end
</code></pre>

The usual error is that the resource have been destoryed. But there are at least other two edge cases - when the resource is not found and when it is not owned. As a rule of thumb think of all the possible inputs and states you can.

<pre><code># Wrong
should 'show the resource'

# Right
context 'when resource is found' do
  should 'respond with 200'
  should 'show destroy the resource'
end

context 'when resource is not found' do
  should 'respond with 404'
end

context 'when resource is not owned' do
  should 'respond with 404'
end
</code></pre>

h2. User factories and not fixtures

Do not use fixtures which are difficult to control, instead use factries. Use them to reduce the verbosity on creating new data.

<pre><code># Wrong
user = User.create(
  :name => "Joe",
  :surname => "Kowalski",
  :city => "La Vida",
  :birth => "21 September 1979"
)

# Right
user = Factory.create(:user)
</code></pre>

h2. Setup & Teardown

In Unit::Test you have the @setup@ method that is called before test and the @teardown@ method that is called after test. They are regular methods and setup is called before all test cases and teardown the other way round.

Shoulda allows you the specify setups and teardowns in different level of contexts and you may use it as many times as you want. Setup should contain only objects, variables and procedures necessary for given context. Otherwise it would slow other test by providing them with "setup" that is no required by them.

<pre><code># Wrong
setup do
  @bear = Factory.build(:bear)
  @kangaroo = Factory.build(:kangaroo)
end

context 'when bear is missing' do
  should 'call police'
  should 'evacuate zoo'
end

context 'when kangaroo is missing'
  should 'inform security'
  should 'inform visitors'
end

# Right
context 'when bear is missing' do
  setup do
    @kangaroo = Factory.build(:kangaroo)
  end
  
  should 'call police'
  should 'evacuate zoo'
end

context 'when kangaroo is missing' do
  setup do
    @bear = Factory.build(:bear)
  end
  
  should 'inform security'
  should 'inform visitors'
end
</code></pre>

h2. Stub or not to stub

Always try to test the real behaviour and everything should be just fine. Anyway, sometimes stubs my be useful, e.g. you stub a filter that you don't want to be run, or a method that is called by the tested behaviour. Stubs make your tests definitely faster, that is beyond question. But never "overstub" your test in a way that would make it hard to understand.

<pre><code>context 'when not found' do
  should 'respond with 404' do
    assert_equal 404, response.status
  end
end
</code></pre> 

h2. Routing tests

Use this unified naming conventions for testing controller routes to have a nice test report if anything goes wrong. Always include HTTP methods in the assertion and keep the order of the keys in hashes the same as on the "Right" example.

<pre><code># Wrong
should 'routes to user' do
  assert_routing('/users/1' , { :controller => "users", :action => "show", :id => "321" })
end

# Wrong (HTTP method not included)
context 'UsersController routing' do
  should 'route to #show' do
    assert_routing('/users/1', :controller => "users", :action => "show", :id => "321")
  end
end

# Right
context 'UsersController routing' do
  should 'route to #show' do
    assert_routing({ :method => 'get', :path => '/users/1' }, { :controller => "users", :action => "show", :id => "321" })
  end
end

</code></pre>

h2. Controller tests

Use contexts to structure controller tests by actions and methods. Contexts delimiting routable actions should include in their name the HTTP method used to call them. Otherwise the same rules as for unit tests apply.

<pre><code># Wrong
context 'destroying' do
  # ommited...
end

context 'sanitize_options' do
  # ommited...
end

# Right
context 'DELETE #destroy' do
  # ommited...
end

context '#sanitize_options' do
  # ommited...
end
</code></pre>

Don't forget to wrap up controller tests to proper context!

<pre><code>context "ArticlesController" do
  # test here...
end
</code></pre>

h1. TODOs

* Discuss everything marked *DISCUSS!!*
* Naming
* The rest after naming in styleguides
* *Unit::Test with Shoulda*
  - Easy to read matcher
  - Mocking (stubbing) HTTP requests



h1. Resources

http://betterspecs.org/
https://github.com/bbatsov/ruby-style-guide
https://github.com/bbatsov/rails-style-guide
https://github.com/styleguide
